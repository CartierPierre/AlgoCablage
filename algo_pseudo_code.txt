//1 Algo le plus court, sans obstacle, avec chevauchement

pour chaque depart
    tant que x_depart != x_arrivee
        parcourir l'axe x
    ftant que
    tant que y_depart != y_arrivee
        parcourir l'axe y
    ftant que
fpour chaque


//2 Algo pas à pas sans obstacle, sans chevauchement

pour chaque depart
    tant que x_depart != x_arrivee
        si axe x deja occupe
            parcourir l'axe y
        sinon
            parcourir l'axe x
        fsi
    ftant que
    tant que y_depart != y_arrivee
        si axe y deja occupe
            parcourir l'axe x
        sinon
            parcourir l'axe y
        fsi
    ftant que
fpour chaque

//3 Algo A* pas à pas avec obstacle, avec chevauchement

Structure nœud = {
      x, y: Nombre
      cout, heuristique: Nombre
   }
   depart = Nœud(x=_, y=_, cout=0, heuristique=0)
Fonction compare2Noeuds(n1:Nœud, n2:Nœud)
       si n1.heuristique < n2.heuristique 
           retourner 1
       ou si n1.heuristique  == n2.heuristique 
           retourner 0
       sinon
           retourner -1
           
Fonction cheminPlusCourt(g:Graphe, objectif:Nœud, depart:Nœud)
        closedList = File()
        openList = FilePrioritaire(comparateur=compare2Noeuds)
        openList.ajouter(depart)
        tant que openList n'est pas vide
           u = openList.depiler()
           si u.x == objectif.x et u.y == objectif.y
               reconstituerChemin(u)
               terminer le programme (sans erreur)
           sinon
               pour chaque voisin v de u dans g
                   si v est une case libre
                       si v existe dans closedList avec un cout inférieur
                        ou si v existe dans openList avec un cout inférieur
                           neRienFaire()
                       sinon
                            v.cout = u.cout +1 
                            v.heuristique = v.cout + distance([v.x, v.y], [objectif.x, objectif.y])
                            openList.ajouter(v)
            closedList.ajouter(u)
       terminer le programme (avec erreur)